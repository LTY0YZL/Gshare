{% load tailwind_cli %}
{% load static %}
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maps</title>
    {% tailwind_css %}
    <style>
    </style>
</head>
{% include "navbar.html" %}
<body class="bg-[#D8D8D8] h-screen">
    

    <div class="h-full flex items-center justify-center">
        {% comment %} <button id="openPopup" class="bg-[#150931] text-white flex justify-center items-center w-32 h-32 rounded-lg transform translate-x-full transition-transform duration-300">
            Open Popup
        </button> {% endcomment %}
        <div id="map_popup" class="flex justify-center items-center w-full">
            <div style="width: 100%; height: 39rem;" id='map' class="h-96 border border-gray-300 rounded-lg shadow-lg">

            </div>
        </div>
        <button id="shareBtn" class="fixed bottom-6 left-6 px-4 py-2 rounded-full shadow-lg bg-blue-600 text-white">
            Start Sharing
        </button>
    </div>

    <!-- pop up html --> 
    <div id="popup" class="fixed top-0 right-0 w-full md:w-1/3 h-full max-h-screen bg-white shadow-2xl z-50 transition-transform transform translate-x-full flex flex-col">
        <!-- header -->
        <div class="flex justify-between items-center border-b p-4">
            <button id="closePopup" class="text-gray-500 hover:text-gray-700 ml-auto text-3xl">&times;</button>
        </div>

        <!-- tabs -->
        <div class="flex items-center justify-center border-b p-2">
            <button id="shop" class="bg-[#EBE5FA] w-1/2 h-12 text-lg font-bold">Shopping Cart</button>
            <button id="person" class="bg-white w-1/2 h-12 text-lg font-bold hover:bg-[#B299EA]">People</button>
        </div>

        <!-- scrollable content -->
        <div id="shoppingcart" class="flex-1 overflow-y-auto p-6">
            <div id="popup-content"></div>
        </div>

        <div id="people" class="hidden flex-1 overflow-y-auto p-6"></div>
    </div>

     {% csrf_token %}
     <script>
        //const openPopup = document.getElementById('openPopup'); 
        const closePopup = document.getElementById('closePopup');
        const shop = document.getElementById('shop');
        const person = document.getElementById('person');
        const map_popup = document.getElementById('map_popup');
        const shoppingcart = document.getElementById('shoppingcart');
        const people = document.getElementById('people');

        closePopup.addEventListener('click', () => {
            const popup = document.getElementById('popup');
            popup.classList.add('translate-x-full');
        });

        // openPopup.addEventListener('click', () => {
        //     popup.classList.remove('translate-x-full');
        //     openPopup.classList.add('-translate-x-10');
        // }); 


        shop.addEventListener('click', () => {
            console.log('person clicked');
            shop.classList.add('bg-[#EBE5FA]');
            person.classList.remove('bg-[#EBE5FA]');
            shop.classList.remove('bg-white');
            person.classList.add('bg-white');
            shoppingcart.classList.remove('hidden');
            people.classList.add('hidden');
            shop.classList.remove('hover:bg-[#B299EA]');
            person.classList.add('hover:bg-[#B299EA]');

        });

        person.addEventListener('click', () => {
            console.log('person clicked');
            person.classList.add('bg-[#EBE5FA]');
            shop.classList.remove('bg-[#EBE5FA]');
            person.classList.remove('bg-white');
            shop.classList.add('bg-white');
            shoppingcart.classList.add('hidden');
            people.classList.remove('hidden');
            person.classList.remove('hover:bg-[#B299EA]');
            shop.classList.add('hover:bg-[#B299EA]');

            loadPeopleData();

        });

        const HUB_URL = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws/location/';
        const WANT_KEY = 'gshare.sharelocation.v1';

        {% comment %} add user id {% endcomment %}
        const CURRENT_UID = {{ request.user.id }};
        const CURRENT_VIEWER_ID = {{ viewer_id }};

        let pageWS  = null;
        let pageWatchId = null;

        let directionsService;
        let directionsRenderer;
        let lastRouteUpdate = 0;
        let activeStorePos = null;  
        let profilePos = null; 
        let storeMarker = null;

        let storeLegPolyline = null;    // driver to store
        let profileLegPolyline = null;  // store to profile
        let directLegPolyline = null;   // driver TO profile WITHOUT STORE,  JUST FOR TEST

        let myActiveMarker = null;

        function circleIcon(fill, stroke) {
            return {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 7,
                fillOpacity: 0.9,
                fillColor: fill,
                strokeColor: stroke,
                strokeWeight: 2,
            };
        }

        const liveMarkers = new Map();  
        let meLiveMarker = null;        

        function ensureLiveMarker(uid, username, role, isMe) {
            if (isMe && meLiveMarker) return meLiveMarker;
            if (!isMe && liveMarkers.has(uid)) return liveMarkers.get(uid);

            const marker = new google.maps.Marker({
                map,
                title: `${username}${role ? ' (' + role + ')' : ''}`,
                icon: isMe ? circleIcon('#1a73e8', '#0b57d0')  
                    : circleIcon('#34a853', '#0b8043'), 
                });

            if (isMe) meLiveMarker = marker; else liveMarkers.set(uid, marker);
            return marker;
        }

        function subscribeHub() {
            if (pageWS) return;
            pageWS = new WebSocket(HUB_URL);

            pageWS.onmessage = (evt) => {
                const data = JSON.parse(evt.data || '{}');
                if (data.type !== 'loc') return;

                const isMe = data.uid === CURRENT_UID;
                const m = ensureLiveMarker(data.uid, data.username, data.role, isMe);
                m.setPosition({ lat: data.lat, lng: data.lng });
            };

            pageWS.onclose = () => {
                pageWS = null;
            };
        }

        function setShareBtn(on) {
            const b = document.getElementById('shareBtn');
            b.textContent = on ? 'Stop Sharing' : 'Start Sharing';
            b.style.color = "black";
        }

        function buildPathFromLeg(leg) {
            const path = [];
            leg.steps.forEach(step => {
                step.path.forEach(p => path.push(p));
            });
            return path;
        }

        function updateRouteFromDriver(driverPos) {
            if (!directionsService) return;
            if (!profilePos) return;  

            const now = Date.now();
            if (now - lastRouteUpdate < 5000) {
                return;
            }
            lastRouteUpdate = now;

            const req = {
                origin: driverPos,
                destination: profilePos,
                travelMode: google.maps.TravelMode.DRIVING
            };

            if (activeStorePos) {
                req.waypoints = [{ location: activeStorePos, stopover: true }];
            }

            directionsService.route(req, (result, status) => {
                if (status !== 'OK') {
                    console.warn('Directions request failed:', status);
                    return;
                }

                const route = result.routes[0];
                const legs = route.legs;

                if (storeLegPolyline) {
                    storeLegPolyline.setMap(null);
                    storeLegPolyline = null;
                }
                if (profileLegPolyline) {
                    profileLegPolyline.setMap(null);
                    profileLegPolyline = null;
                }
                if (directLegPolyline) {
                    directLegPolyline.setMap(null);
                    directLegPolyline = null;
                }

                if (legs.length === 2) {
                    const pathToStore = buildPathFromLeg(legs[0]);
                    storeLegPolyline = new google.maps.Polyline({
                        map,
                        path: pathToStore,
                        strokeColor: '#EE0000',   
                        strokeOpacity: 1.0,
                        strokeWeight: 6
                    });

                    const pathToProfile = buildPathFromLeg(legs[1]);
                    profileLegPolyline = new google.maps.Polyline({
                        map,
                        path: pathToProfile,
                        strokeColor: '#66ccff',   
                        strokeOpacity: 1.0,
                        strokeWeight: 6
                    });
                } else if (legs.length === 1) {
                    const pathDirect = buildPathFromLeg(legs[0]);
                    directLegPolyline = new google.maps.Polyline({
                        map,
                        path: pathDirect,
                        strokeColor: '#66ccff',  
                        strokeOpacity: 1.0,
                        strokeWeight: 6
                    });
                }
                map.fitBounds(route.bounds)
            });
        }      

        function startSharingNow(role='buyer') {
            localStorage.setItem(WANT_KEY, '1');
            setShareBtn(true);

            if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
            if (pageWatchId !== null) return;

            if (!pageWS) subscribeHub();  

            function sendPing(lat, lng, acc) {
                if (pageWS && pageWS.readyState === 1) {
                    pageWS.send(JSON.stringify({ type: 'ping', lat, lng, role, accuracy: acc }));
                }
            }

            pageWatchId = navigator.geolocation.watchPosition(
                (pos) => {
                    const { latitude, longitude, accuracy } = pos.coords;

                    const driverPos = { lat: latitude, lng: longitude };
                    const me = ensureLiveMarker(CURRENT_UID, 'You', role, true);
                    me.setPosition(driverPos);
                    sendPing(latitude, longitude, accuracy);
                    updateRouteFromDriver(driverPos);
                },
                (err) => {
                    console.error(err);
                    alert('Location permission or GPS issue.');
                    stopSharingNow();
                },
                { enableHighAccuracy: true, maximumAge: 2000, timeout: 8000 }
            );
        }
        

        function stopSharingNow() {
            localStorage.removeItem(WANT_KEY);
            setShareBtn(false);
            if (pageWatchId !== null) {
                navigator.geolocation.clearWatch(pageWatchId);
                pageWatchId = null;
            }
        }

        document.getElementById('shareBtn').addEventListener('click', () => {
            if (localStorage.getItem(WANT_KEY)) stopSharingNow(); else startSharingNow('buyer');
        });

        function afterMapReady() {
            subscribeHub();                         
            setShareBtn(!!localStorage.getItem(WANT_KEY));  
        }

        let map;
        let geocoder;
        let markers = {};

        {% comment %} const addresses_with_info = JSON.parse('{{ delivery_addresses_with_info_json|escapejs }}'); {% endcomment %}
        const user_address = '{{ user_address|escapejs }}';
        let fetchTimeout = null; // for debouncing


        function initMap() {
            // Create a map centered at a specific location
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 17
            });
            geocoder = new google.maps.Geocoder();

            geocoder.geocode({ 'address': user_address }, (results, status) => {
                if (status === 'OK') {
                    const location = results[0].geometry.location;
                    map.setCenter(location);
                } else {
                    alert('Geocode was not successful for the following reason: ' + status);
                }
            });

            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({map, suppressMarkers: true});

            map.addListener("idle", () => {
                if (fetchTimeout) clearTimeout(fetchTimeout);
                fetchTimeout = setTimeout(fetchMapData, 500); // wait 0.5s after idle
            });
            setInterval(fetchMapData, 5000);
            afterMapReady();
        }
        let user = "";

        function fetchMapData() {

            const bounds = map.getBounds();
            if (!bounds) {
                console.warn("Map bounds not available yet.");
                return;
            }

            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            const maxLat = ne.lat();
            const maxLng = ne.lng();
            const minLat = sw.lat();
            const minLng = sw.lng();
            console.log(`Map bounds: NE(${maxLat}, ${maxLng}), SW(${minLat}, ${minLng})`);

            // Fetch maps data asynchronously after map loads
            const url = `/maps/maps-data/${minLat}/${minLng}/${maxLat}/${maxLng}/`;
            fetch(url)
                .then(res => {
                    const userName = res.headers.get('X-User-Name');
                    console.log("fetched username from header:", userName);
                    user = userName;
                    return res.json();
                })
                .then(data => {
                    console.log("maps data received:", data);
                    addMarkers(data);

                    loadPeopleData();
                })
                .catch(err => console.error("Error fetching delivery data:", err));
        }


        function addMarkers(addressGroups) {
            const bounds = map.getBounds();
            if (!bounds) {
                console.warn("Map bounds not available yet.");
                return;
            }

            for (const [address, marker] of Object.entries(markers)) {
                if (!bounds.contains(marker.getPosition())) {
                    marker.setMap(null);
                    delete markers[address];
                }
            }

            addressGroups.forEach(group => {
                const address = group.address;
                if (!address || address.trim().length < 5) {
                    console.warn("Skipping invalid address:", address);
                    return;
                }
                if (markers[address]) return;
                geocoder.geocode({ address }, (results, status) => {
                    if (status !== 'OK') {
                        console.error("Geocode failed:", status);
                        return;
                    }

                    const location = results[0].geometry.location;

                    const marker = new google.maps.Marker({
                        map,
                        position: location,
                        title: `Orders at ${address}`,
                    });

                    marker.addListener('click', () => {
                        showPopup(group);
                        setTimeout(() => shop.click(), 100);

                        profilePos = location;

                        const order = group.orders && group.orders.length > 0 ? group.orders[0] : null;
                        if (!order) {
                            console.warn('No order data for this marker.');
                            return;
                        }

                        const rawLat = order.store_lat;
                        const rawLng = order.store_lng;
                        const lat = rawLat !== null && rawLat !== undefined ? parseFloat(rawLat) : NaN;
                        const lng = rawLng !== null && rawLng !== undefined ? parseFloat(rawLng) : NaN;

                        console.log('order', order);
                        console.log('parsed store lat/lng:', lat, lng);

                        if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
                            activeStorePos = { lat, lng };

                            if (!storeMarker) {
                                storeMarker = new google.maps.Marker({
                                    map,
                                    position: activeStorePos,
                                    title: order.store_name ? `Store: ${order.store_name}` : 'Store',
                                    icon: {
                                        path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW,
                                        scale: 6,
                                        fillColor: '#66ccff',
                                        fillOpacity: 1,
                                        strokeColor: '#cc9900ff',
                                        strokeWeight: 2,
                                    },
                                });
                            } else {
                                storeMarker.setPosition(activeStorePos);
                                storeMarker.setTitle(order.store_name ? `Store: ${order.store_name}` : 'Store');
                                storeMarker.setMap(map);
                            }

                            if (meLiveMarker) {
                                updateRouteFromDriver(meLiveMarker.getPosition());
                            }
                            return; 
                        }

                        if (order.store_address) {
                            const geocodeRequest = {
                                address: order.store_address,
                                bounds: map.getBounds(),
                                componentRestrictions: { country: 'US' },
                            };

                            geocoder.geocode(geocodeRequest, (results2, status2) => {
                                if (status2 !== 'OK' || !results2[0]) {
                                    console.warn('Store geocode failed:', status2);
                                    if (meLiveMarker) updateRouteFromDriver(meLiveMarker.getPosition());
                                    return;
                                }

                                const storeLoc = results2[0].geometry.location;
                                activeStorePos = storeLoc;

                                if (!storeMarker) {
                                    storeMarker = new google.maps.Marker({
                                        map,
                                        position: storeLoc,
                                        title: order.store_name ? `Store: ${order.store_name}` : 'Store',
                                        icon: {
                                            path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW,
                                            scale: 6,
                                            fillColor: '#66ccff',
                                            fillOpacity: 1,
                                            strokeColor: '#cc9900ff',
                                            strokeWeight: 2,
                                        },
                                    });
                                } else {
                                    storeMarker.setPosition(storeLoc);
                                    storeMarker.setTitle(order.store_name ? `Store: ${order.store_name}` : 'Store');
                                    storeMarker.setMap(map);
                                }

                                if (meLiveMarker) {
                                    updateRouteFromDriver(meLiveMarker.getPosition());
                                }
                            });
                        } else {
                            console.warn('No store info for this order; routing directly to profile.');
                            activeStorePos = null;

                            if (storeMarker) {
                                storeMarker.setMap(null);
                                storeMarker = null;
                            }

                            if (meLiveMarker) {
                                updateRouteFromDriver(meLiveMarker.getPosition());
                            }
                        }
                    });

                    markers[address] = marker;

                    const hasMyActiveOrder = group.orders.some(o =>
                        o.status === 'inprogress' &&
                        (o.user_id === CURRENT_VIEWER_ID || o.driver_id === CURRENT_VIEWER_ID)
                    );

                    if (hasMyActiveOrder) {
                        myActiveMarker = marker;
                        google.maps.event.trigger(marker, 'click');
                    }
                });
            });
        }

        let popupJustOpened = false;

        function showPopup(group) {
            console.log("popup");
            let ordersHTML = group.orders.map(order => {
            const isBuyer  = (order.user_id === CURRENT_VIEWER_ID);
            const isDriver = (order.driver_id === CURRENT_VIEWER_ID);

            let actionHtml = '';

            if (order.status === 'placed') {
                const buttonText = isBuyer ? "Take own order" : "Send Request";
                actionHtml = `
                    <button class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mt-2"
                            onclick="changeOrderStatus(${order.order_id}, 'pending')">
                        ${buttonText}
                    </button>
                `;
            } else if (order.status === 'inprogress') {
                const canConfirm = isBuyer || isDriver;

                let baseText = '';
                if (isBuyer && isDriver) {
                    baseText = `
                    <p class="mt-2 text-green-700 font-semibold">
                        You are picking up your own order.
                    </p>
                `;
                } else if (isDriver) {
                    baseText = `
                        <p class="mt-2 text-green-700 font-semibold">
                            You are delivering this order.
                         </p>
                        `;
                } else if (isBuyer) {
                    baseText = `
                        <p class="mt-2 text-blue-700 font-semibold">
                            Your order is in progress.<br>
                            {% comment %} Driver: ${order.driver_name || 'TBD'} {% endcomment %}
                        </p>
                    `;
                } else {
                    baseText = `
                        <p class="mt-2 text-gray-500">
                            This order has already been accepted.
                        </p>
                    `;
                }

                {% comment %} const buttonHtml = canConfirm ? `
                    <button button class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mt-2""
                        onclick="confirmDelivered(${order.order_id})">
                        Mark as delivered
                    </button>
                ` : ''; {% endcomment %}
                {% comment %} const delivery = `<p class="mt-2 text-black font-semibold">
                    Delivery in progress...
                </p>`; {% endcomment %}

                actionHtml = baseText;

            } else {
                actionHtml = `
                    <p class="mt-2 text-gray-500">
                        Order status: ${order.status}
                    </p>
                `;
            }

            return `
                <div class="border-t border-gray-300 mt-4 pt-4">
                    <p class="text-gray-700 text-xl"><b>Address:</b> ${group.address}</p>
                    <ul class="list-disc pl-6">
                        ${order.items.map(item => `
                            <li class="mb-1 border border-gray-300 rounded-lg p-2 mt-2">
                                <span class="font-semibold">${item.name}</span>:
                                <span class="font-semibold">${item.quantity} Ã— $${item.price} =</span>
                                <span class="text-blue-700 font-bold">$${item.total.toFixed(2)}</span>
                            </li>
                        `).join('')}
                    </ul>
                    <p class="text-right text-lg font-bold mt-2">
                        Subtotal: $${order.subtotal.toFixed(2)}
                    </p>
                    ${actionHtml}
                </div>
            `;
        }).join('');

        const popup = document.getElementById('popup');
        console.log("popup element found?", popup);
        console.log("popup classes before:", popup?.classList.value);

        const userName = group.orders[0].user;
        const userId   = group.orders[0].user_id;

        popup.classList.remove('translate-x-full');
        console.log("popup classes after:", popup.classList.value);

        document.getElementById('popup-content').innerHTML = `
            <div class="space-y-4">
                <a href="/profile/${userId}/" class="no-underline hover:underline">
                    <h2 class="text-4xl font-bold mb-2 text-center">${userName}</h2>
                </a>
                ${ordersHTML}
            </div>
        `;

        console.log("end");
        popupJustOpened = true
    }

    function confirmDelivered(orderId) {
        fetch(`/orders/${orderId}/confirm_delivery/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}',
            },
            body: JSON.stringify({}),
        })
        .then(r => r.json())
        .then(data => {
            if (!data.success) {
                alert(data.error || 'Failed to confirm delivery');
                return;
            }
            if (data.fully_delivered) {
                alert('Order marked delivered by both buyer and driver.');
                window.location.reload();
            } else {
                alert('Thanks! Waiting for the other person to confirm.');
            }
        })
        .catch(err => {
            console.error(err);
            alert('Error confirming delivery.');
        });
    }

        function geocodeAddress() {
            const address = document.getElementById('input_location').value;
            geocoder.geocode({ 'address': address }, (results, status) => {
                if (status === 'OK') {
                    const location = results[0].geometry.location;
                    map.setCenter(location);
                    document.getElementById('input_location').value = '';


                } else {
                    alert('Geocode was not successful for the following reason: ' + status);
                }
            });
        } 

        function loadPeopleData() {

            const bounds = map.getBounds();
            if (!bounds) {
                console.warn("Map bounds not available yet.");
                return;
            }

            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            const maxLat = ne.lat();
            const maxLng = ne.lng();
            const minLat = sw.lat();
            const minLng = sw.lng();
            console.log(`Map bounds: NE(${maxLat}, ${maxLng}), SW(${minLat}, ${minLng})`);

            // Fetch maps data asynchronously after map loads
            const url = `/maps/people-data/${minLat}/${minLng}/${maxLat}/${maxLng}/`;
            fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                })
                .then(response => response.json())
                .then(data => {
                    console.log("People data received:", data);
                    const peopleDiv = document.getElementById('people');

                    // Example rendering of people data
                    peopleDiv.innerHTML = `
                        <div class="p-4 space-y-2">
                            <h3 class="text-2xl font-bold mb-4">Nearby People</h3>
                            ${data.people.map(person => `
                                <div class="border p-3 rounded-lg bg-gray-100">
                                    <a href="/profile/${person.user_id}/" class="no-underline hover:underline">
                                        <p class="font-semibold">${person.name}</p>
                                    </a>
                                    <p class="text-sm text-gray-600">${person.address}</p>
                                    <p class="text-sm text-gray-600">Order Price: $${person.order_data.subtotal}</p>
                                </div>
                            `).join('')}
                        </div>
                    `;
                })
                .catch(error => {
                    console.error("Error loading people data:", error);
                    document.getElementById('people').innerHTML = "<p class='text-red-500 p-4'>Failed to load people data.</p>";
                });
            }

        function changeOrderStatus(orderId, newStatus) {
            fetch(`/change_order_status/${orderId}/${newStatus}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'  // Include CSRF token for security
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Order status updated successfully!');
                    createDelivery(orderId);
                    window.location.reload();

                    
                } else {
                    alert('Failed to update order status.');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred while updating the order status.');
            });
        }

        function createDelivery(orderId) {
            fetch(`/create_delivery/${orderId}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'  // Include CSRF token for security
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Delivery created successfully!');
                    
                } else {
                    console.log('Failed to create delivery.');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                console.log('An error occurred while creating the delivery.');
            });
        }

        {% comment %} window.addEventListener('load', initMap) {% endcomment %}
    </script>

    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap">

    </script>

</body>